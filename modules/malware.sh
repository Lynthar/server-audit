#!/usr/bin/env bash
# vpssec - VPS Security Check & Hardening Tool
# Malware detection module
# Copyright (c) 2024
#
# IMPORTANT: This module is AUDIT ONLY
# - NO automatic removal of malware
# - NO automatic process killing
# - NO automatic file deletion
# - All findings are ALERT ONLY - require human review
#
# This module detects:
# - Rootkits (lightweight detection without external tools)
# - Crypto miners and mining pool connections
# - WebShells in web directories
# - Suspicious processes (deleted binaries, memfd execution)
# - Abnormal network connections (reverse shells, C2)

# ==============================================================================
# Configuration
# ==============================================================================

# Known crypto miner process patterns
declare -a CRYPTO_PROCESS_PATTERNS=(
    "xmrig" "xmr-stak" "minerd" "cpuminer"
    "ccminer" "cgminer" "bfgminer" "ethminer"
    "kswapd0"  # Fake system process name often used by miners
    "watchdogs" "kerberods" "kdevtmpfsi" "kinsing"
    "xmr" "monero" "randomx"
)

# Known mining pool hostname patterns
declare -a CRYPTO_POOL_PATTERNS=(
    "pool.minergate.com" "xmrpool.eu"
    "monerohash.com" "nanopool.org"
    "minexmr.com" "supportxmr.com"
    "hashvault.pro" "f2pool.com"
    "antpool.com" "poolin.com"
    "mining-dutch.nl" "cryptonight"
)

# Common mining pool ports
declare -a CRYPTO_POOL_PORTS=(
    3333 4444 5555 7777 8888 9999
    14433 45700 45560 13531
)

# Web directories to scan for webshells
declare -a WEB_DIRECTORIES=(
    "/var/www"
    "/home/*/public_html"
    "/usr/share/nginx/html"
    "/var/www/html"
    "/var/www/vhosts"
    "/opt/lampp/htdocs"
    "/srv/www"
)

# PHP WebShell patterns
declare -a WEBSHELL_PATTERNS=(
    # Direct command execution with user input
    'eval\s*\(\s*\$_(POST|GET|REQUEST|COOKIE)'
    'eval\s*\(\s*base64_decode'
    'eval\s*\(\s*gzinflate'
    'eval\s*\(\s*gzuncompress'
    'eval\s*\(\s*str_rot13'
    'assert\s*\(\s*\$_'
    'preg_replace\s*\([^,]*\/[a-z]*e[a-z]*\s*,'
    'create_function\s*\([^)]*\$'
    # System command execution
    'system\s*\(\s*\$_(POST|GET|REQUEST)'
    'passthru\s*\(\s*\$_(POST|GET|REQUEST)'
    'shell_exec\s*\(\s*\$_(POST|GET|REQUEST)'
    'exec\s*\(\s*\$_(POST|GET|REQUEST)'
    'popen\s*\(\s*\$_(POST|GET|REQUEST)'
    'proc_open\s*\(\s*\$_(POST|GET|REQUEST)'
    # Obfuscation patterns
    '\$[a-z]{1,2}\s*=\s*chr\s*\(\s*[0-9]+'
    'str_rot13\s*\(\s*base64_decode'
    'base64_decode\s*\(\s*str_rot13'
    # Common webshell signatures
    'c99shell' 'r57shell' 'c100' 'b374k'
    'WSO\s*[0-9]' 'FilesMan' 'Ani-Shell'
)

# Suspicious outbound ports (RAT, backdoor common ports)
declare -a SUSPICIOUS_OUTBOUND_PORTS=(
    4444 5555 6666 7777 8888    # Common RAT ports
    1234 12345 31337            # Classic backdoor ports
    9001 9002                   # TOR/Onion ports
    6667 6668 6669              # IRC (C2 sometimes uses)
)

# Known C2 port patterns
declare -a C2_PORTS=(
    4444 5554 5555 6666 7777 8080 8443
    31337 12345 23456 54321
)

# CPU threshold for crypto mining detection (percentage)
CRYPTO_CPU_THRESHOLD=80

# Max files to scan in each web directory (prevent hang on huge dirs)
MAX_WEBSHELL_SCAN_FILES=1000

# ==============================================================================
# Helper Functions
# ==============================================================================

# Get list of process IDs from /proc
_malware_get_proc_pids() {
    for pid_dir in /proc/[0-9]*; do
        local pid="${pid_dir##*/}"
        [[ -d "$pid_dir" && "$pid" =~ ^[0-9]+$ ]] && echo "$pid"
    done
}

# Get list of process IDs from ps
_malware_get_ps_pids() {
    ps -eo pid --no-headers 2>/dev/null | tr -d ' '
}

# Get TCP connections from /proc/net/tcp
_malware_get_proc_ports() {
    local ports=()
    local files=("/proc/net/tcp" "/proc/net/tcp6")

    for file in "${files[@]}"; do
        [[ -f "$file" ]] || continue
        while read -r line; do
            # Skip header
            [[ "$line" =~ ^[[:space:]]*sl ]] && continue
            # Extract local port (hex)
            local local_addr=$(echo "$line" | awk '{print $2}')
            local port_hex="${local_addr##*:}"
            local port=$((16#$port_hex))
            [[ $port -gt 0 ]] && ports+=("$port")
        done < "$file"
    done

    printf '%s\n' "${ports[@]}" | sort -nu
}

# Get listening ports from ss
_malware_get_ss_ports() {
    ss -tlnH 2>/dev/null | awk '{print $4}' | grep -oE '[0-9]+$' | sort -nu
}

# ==============================================================================
# Rootkit Detection Functions
# ==============================================================================

# Check for hidden processes (ps vs /proc comparison)
_malware_check_hidden_processes() {
    local hidden=()
    local proc_pids=$(_malware_get_proc_pids | sort -n)
    local ps_pids=$(_malware_get_ps_pids | sort -n)

    # Find PIDs in /proc but not in ps output (potential hidden processes)
    while read -r pid; do
        [[ -z "$pid" ]] && continue
        if ! echo "$ps_pids" | grep -q "^${pid}$"; then
            # Verify process still exists and isn't a kernel thread
            if [[ -d "/proc/$pid" ]] && [[ -f "/proc/$pid/exe" ]]; then
                local cmdline=$(tr '\0' ' ' < "/proc/$pid/cmdline" 2>/dev/null)
                [[ -n "$cmdline" ]] && hidden+=("$pid:$cmdline")
            fi
        fi
    done <<< "$proc_pids"

    printf '%s\n' "${hidden[@]}"
}

# Check for hidden ports (ss vs /proc/net comparison)
_malware_check_hidden_ports() {
    local hidden=()
    local proc_ports=$(_malware_get_proc_ports)
    local ss_ports=$(_malware_get_ss_ports)

    # Find ports in /proc but not in ss output
    while read -r port; do
        [[ -z "$port" ]] && continue
        if ! echo "$ss_ports" | grep -q "^${port}$"; then
            hidden+=("$port")
        fi
    done <<< "$proc_ports"

    printf '%s\n' "${hidden[@]}"
}

# Check for LD_PRELOAD hijacking
_malware_check_ld_preload() {
    local findings=()

    # Check environment files for LD_PRELOAD
    local env_files=(
        "/etc/profile"
        "/etc/profile.d/"*.sh
        "/etc/environment"
        "/etc/bash.bashrc"
        "/root/.bashrc"
        "/root/.profile"
    )

    for file in "${env_files[@]}"; do
        [[ -f "$file" ]] || continue
        if grep -q "LD_PRELOAD" "$file" 2>/dev/null; then
            local content=$(grep "LD_PRELOAD" "$file" 2>/dev/null | head -1)
            findings+=("$file: $content")
        fi
    done

    printf '%s\n' "${findings[@]}"
}

# Check /etc/ld.so.preload
_malware_check_library_preload() {
    local findings=()

    if [[ -f /etc/ld.so.preload ]]; then
        if [[ -s /etc/ld.so.preload ]]; then
            # Non-empty ld.so.preload is very suspicious
            local libs=$(cat /etc/ld.so.preload 2>/dev/null)
            findings+=("Non-empty /etc/ld.so.preload: $libs")

            # Check if the preloaded libraries exist and are signed
            while read -r lib; do
                [[ -z "$lib" || "$lib" =~ ^# ]] && continue
                if [[ ! -f "$lib" ]]; then
                    findings+=("Preloaded library not found: $lib")
                fi
            done < /etc/ld.so.preload
        fi
    fi

    printf '%s\n' "${findings[@]}"
}

# Check for suspicious kernel modules
_malware_check_suspicious_lkm() {
    local findings=()

    # Get list of loaded modules
    if [[ -f /proc/modules ]]; then
        while read -r mod_line; do
            local mod_name=$(echo "$mod_line" | awk '{print $1}')
            local mod_file="/sys/module/$mod_name"

            # Check for hidden modules (in /proc but not in /sys)
            if [[ ! -d "$mod_file" ]]; then
                findings+=("Hidden kernel module (no /sys entry): $mod_name")
            fi

            # Check module reference count of 0 with no dependents (potentially hiding)
            local refcount=$(echo "$mod_line" | awk '{print $3}')
            local deps=$(echo "$mod_line" | awk '{print $4}')
            if [[ "$refcount" == "0" && "$deps" == "-" ]]; then
                # Could be legitimate, but worth noting in strict mode
                # findings+=("Unused kernel module: $mod_name")
                :
            fi
        done < /proc/modules
    fi

    # Check for modules loaded from unusual paths
    if command -v modinfo &>/dev/null; then
        while read -r mod_name; do
            [[ -z "$mod_name" ]] && continue
            local mod_path=$(modinfo -F filename "$mod_name" 2>/dev/null)
            if [[ -n "$mod_path" && ! "$mod_path" =~ ^/lib/modules/ ]]; then
                findings+=("Module from unusual path: $mod_name -> $mod_path")
            fi
        done < <(lsmod 2>/dev/null | tail -n +2 | awk '{print $1}')
    fi

    printf '%s\n' "${findings[@]}"
}

# ==============================================================================
# Crypto Miner Detection Functions
# ==============================================================================

# Check for crypto mining processes
_malware_check_crypto_processes() {
    local findings=()

    # Build pattern for grep
    local pattern=$(printf '%s\n' "${CRYPTO_PROCESS_PATTERNS[@]}" | paste -sd'|' -)

    # Check process names and command lines
    while read -r line; do
        [[ -z "$line" ]] && continue
        local pid=$(echo "$line" | awk '{print $1}')
        local cmd=$(echo "$line" | awk '{for(i=2;i<=NF;i++) printf $i" "; print ""}')

        if echo "$cmd" | grep -qiE "$pattern"; then
            findings+=("$pid|$cmd")
        fi
    done < <(ps -eo pid,args --no-headers 2>/dev/null)

    printf '%s\n' "${findings[@]}"
}

# Check for connections to mining pools
_malware_check_crypto_connections() {
    local findings=()

    # Build hostname pattern
    local host_pattern=$(printf '%s\n' "${CRYPTO_POOL_PATTERNS[@]}" | paste -sd'|' -)

    # Build port pattern
    local port_pattern=$(printf '%s\n' "${CRYPTO_POOL_PORTS[@]}" | paste -sd'|' -)

    # Check established connections
    while read -r line; do
        [[ -z "$line" ]] && continue

        local remote=$(echo "$line" | awk '{print $5}')
        local state=$(echo "$line" | awk '{print $1}')

        [[ "$state" != "ESTAB" ]] && continue

        # Check if connecting to known mining pool ports
        local remote_port="${remote##*:}"
        if echo "$remote_port" | grep -qE "^($port_pattern)$"; then
            local pid_info=$(echo "$line" | grep -oP 'pid=\K[0-9]+' || echo "unknown")
            findings+=("Mining pool port connection: $remote (PID: $pid_info)")
        fi
    done < <(ss -tnp 2>/dev/null)

    # Check DNS for known pool hostnames (if host command available)
    if command -v host &>/dev/null; then
        for pattern in "${CRYPTO_POOL_PATTERNS[@]}"; do
            if ss -tn 2>/dev/null | grep -qi "$pattern"; then
                findings+=("Connection to mining pool hostname: $pattern")
            fi
        done
    fi

    printf '%s\n' "${findings[@]}"
}

# Check for suspicious high CPU usage
_malware_check_cpu_anomaly() {
    local findings=()

    while read -r line; do
        [[ -z "$line" ]] && continue
        local cpu=$(echo "$line" | awk '{print $1}' | cut -d. -f1)
        local pid=$(echo "$line" | awk '{print $2}')
        local cmd=$(echo "$line" | awk '{for(i=3;i<=NF;i++) printf $i" "; print ""}')

        # Skip if CPU is below threshold
        [[ "$cpu" -lt "$CRYPTO_CPU_THRESHOLD" ]] && continue

        # Skip known high-CPU processes
        if echo "$cmd" | grep -qE "(apt|dpkg|gcc|make|node|python|java|mysql|postgres)"; then
            continue
        fi

        findings+=("$pid|$cpu%|$cmd")
    done < <(ps -eo pcpu,pid,args --sort=-pcpu --no-headers 2>/dev/null | head -10)

    printf '%s\n' "${findings[@]}"
}

# ==============================================================================
# WebShell Detection Functions
# ==============================================================================

# Check for webshells in web directories
_malware_check_webshell() {
    local findings=()

    for dir_pattern in "${WEB_DIRECTORIES[@]}"; do
        # Expand glob patterns
        for dir in $dir_pattern; do
            [[ -d "$dir" ]] || continue

            # Build regex pattern
            local pattern=$(printf '%s\n' "${WEBSHELL_PATTERNS[@]}" | paste -sd'|' -)

            # Find and scan PHP files
            local count=0
            while IFS= read -r -d '' file; do
                ((count++))
                [[ $count -gt $MAX_WEBSHELL_SCAN_FILES ]] && break

                if grep -lqE "$pattern" "$file" 2>/dev/null; then
                    # Get matching line for context
                    local match=$(grep -m1 -E "$pattern" "$file" 2>/dev/null | head -c 100)
                    findings+=("$file|$match")
                fi
            done < <(find "$dir" -maxdepth 5 -name "*.php" -type f -print0 2>/dev/null)

            # Check for hidden PHP files (dot files)
            while IFS= read -r -d '' file; do
                findings+=("$file|Hidden PHP file")
            done < <(find "$dir" -maxdepth 5 \( -name ".*php" -o -name ".*.php" \) -type f -print0 2>/dev/null)

            # Check for PHP files with execute permission (unusual)
            while IFS= read -r -d '' file; do
                findings+=("$file|PHP with execute permission")
            done < <(find "$dir" -maxdepth 5 -name "*.php" -type f -perm /111 -print0 2>/dev/null | head -20)

            # Check recently modified PHP files (last 7 days)
            while IFS= read -r -d '' file; do
                if grep -lqE "$pattern" "$file" 2>/dev/null; then
                    local mtime=$(stat -c %y "$file" 2>/dev/null | cut -d' ' -f1)
                    findings+=("$file|Recent file with suspicious content (modified: $mtime)")
                fi
            done < <(find "$dir" -maxdepth 5 -name "*.php" -type f -mtime -7 -print0 2>/dev/null | head -50)
        done
    done

    # Deduplicate findings
    printf '%s\n' "${findings[@]}" | sort -u
}

# ==============================================================================
# Suspicious Process Detection Functions
# ==============================================================================

# Check for processes with deleted binaries
_malware_check_deleted_binaries() {
    local findings=()

    for pid_dir in /proc/[0-9]*; do
        local pid="${pid_dir##*/}"
        [[ -d "$pid_dir" ]] || continue

        local exe=$(readlink "$pid_dir/exe" 2>/dev/null)
        if [[ "$exe" == *"(deleted)"* ]]; then
            local cmdline=$(tr '\0' ' ' < "$pid_dir/cmdline" 2>/dev/null | head -c 200)
            findings+=("$pid|$exe|$cmdline")
        fi
    done

    printf '%s\n' "${findings[@]}"
}

# Check for memfd execution (fileless malware)
_malware_check_memfd_processes() {
    local findings=()

    for pid_dir in /proc/[0-9]*; do
        local pid="${pid_dir##*/}"
        [[ -d "$pid_dir" ]] || continue

        local exe=$(readlink "$pid_dir/exe" 2>/dev/null)
        if [[ "$exe" == *"/memfd:"* ]]; then
            local cmdline=$(tr '\0' ' ' < "$pid_dir/cmdline" 2>/dev/null | head -c 200)
            findings+=("$pid|$exe|$cmdline")
        fi
    done

    printf '%s\n' "${findings[@]}"
}

# Check for processes running from suspicious paths
_malware_check_suspicious_paths() {
    local findings=()
    local suspicious_paths=(
        "/tmp/"
        "/var/tmp/"
        "/dev/shm/"
        "/run/shm/"
        "/dev/mqueue/"
    )

    for pid_dir in /proc/[0-9]*; do
        local pid="${pid_dir##*/}"
        [[ -d "$pid_dir" ]] || continue

        local exe=$(readlink "$pid_dir/exe" 2>/dev/null)
        [[ -z "$exe" ]] && continue

        for sus_path in "${suspicious_paths[@]}"; do
            if [[ "$exe" == "$sus_path"* ]]; then
                local cmdline=$(tr '\0' ' ' < "$pid_dir/cmdline" 2>/dev/null | head -c 200)
                findings+=("$pid|$exe|$cmdline")
                break
            fi
        done
    done

    printf '%s\n' "${findings[@]}"
}

# Check for unusual parent-child process relationships
_malware_check_unusual_parents() {
    local findings=()

    # Shells with network connections (potential reverse shell)
    while read -r pid; do
        [[ -z "$pid" ]] && continue

        # Check if it's a shell process
        local cmdline=$(tr '\0' ' ' < "/proc/$pid/cmdline" 2>/dev/null)
        if echo "$cmdline" | grep -qE "^(bash|sh|dash|zsh|ksh)"; then
            # Check if it has network file descriptors
            if ls -la "/proc/$pid/fd" 2>/dev/null | grep -q "socket:"; then
                local ppid=$(awk '/^PPid:/{print $2}' "/proc/$pid/status" 2>/dev/null)
                local parent_cmd=$(tr '\0' ' ' < "/proc/$ppid/cmdline" 2>/dev/null)
                findings+=("$pid|Shell with socket FD|Parent: $ppid ($parent_cmd)")
            fi
        fi
    done < <(_malware_get_proc_pids)

    printf '%s\n' "${findings[@]}"
}

# ==============================================================================
# Network Anomaly Detection Functions
# ==============================================================================

# Check for reverse shell connections
_malware_check_reverse_shells() {
    local findings=()

    # Find shell processes with network connections
    for pid in $(pgrep -x "bash|sh|dash|zsh|ash|ksh" 2>/dev/null); do
        # Check file descriptors for sockets
        local has_socket=false
        for fd in /proc/$pid/fd/*; do
            local link=$(readlink "$fd" 2>/dev/null)
            if [[ "$link" == "socket:"* ]]; then
                has_socket=true
                local socket_inode="${link#socket:[}"
                socket_inode="${socket_inode%]}"

                # Try to find the connection details
                local conn=$(grep "$socket_inode" /proc/net/tcp /proc/net/tcp6 2>/dev/null | head -1)
                if [[ -n "$conn" ]]; then
                    findings+=("PID $pid: Shell with network socket (inode: $socket_inode)")
                fi
            fi
        done
    done

    printf '%s\n' "${findings[@]}"
}

# Check for C2 connections
_malware_check_c2_connections() {
    local findings=()

    # Build C2 port pattern
    local port_pattern=$(printf '%s\n' "${C2_PORTS[@]}" | paste -sd'|' -)
    local sus_port_pattern=$(printf '%s\n' "${SUSPICIOUS_OUTBOUND_PORTS[@]}" | paste -sd'|' -)

    # Check outbound connections
    while read -r line; do
        [[ -z "$line" ]] && continue

        local state=$(echo "$line" | awk '{print $1}')
        [[ "$state" != "ESTAB" ]] && continue

        local remote=$(echo "$line" | awk '{print $5}')
        local remote_port="${remote##*:}"
        local remote_ip="${remote%:*}"

        # Check suspicious ports
        if echo "$remote_port" | grep -qE "^($port_pattern|$sus_port_pattern)$"; then
            local proc_info=$(echo "$line" | grep -oP 'users:\(\("\K[^"]+' || echo "unknown")
            findings+=("Suspicious outbound: $remote (Process: $proc_info)")
        fi
    done < <(ss -tnp 2>/dev/null)

    printf '%s\n' "${findings[@]}"
}

# Check for unusual outbound connections
_malware_check_unusual_outbound() {
    local findings=()

    # Count connections per remote IP
    declare -A ip_counts
    while read -r line; do
        local state=$(echo "$line" | awk '{print $1}')
        [[ "$state" != "ESTAB" ]] && continue

        local remote=$(echo "$line" | awk '{print $5}')
        local remote_ip="${remote%:*}"

        # Skip local and private IPs
        if [[ "$remote_ip" =~ ^(127\.|10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|::1|fe80:) ]]; then
            continue
        fi

        ((ip_counts["$remote_ip"]++))
    done < <(ss -tnH 2>/dev/null)

    # Flag IPs with many connections (potential C2 beaconing)
    for ip in "${!ip_counts[@]}"; do
        if [[ ${ip_counts[$ip]} -gt 10 ]]; then
            findings+=("High connection count to $ip: ${ip_counts[$ip]} connections")
        fi
    done

    printf '%s\n' "${findings[@]}"
}

# ==============================================================================
# Audit Function
# ==============================================================================

malware_audit() {
    log_info "Running malware detection audit"

    local check_json
    local total_findings=0

    # === Rootkit Detection ===
    print_item "$(i18n 'malware.checking_rootkit' 2>/dev/null || echo 'Checking for rootkit indicators...')"

    # 1. Hidden processes
    local hidden_procs=$(_malware_check_hidden_processes)
    local hidden_procs_count=$(echo "$hidden_procs" | grep -c '.' 2>/dev/null || echo 0)

    if [[ -n "$hidden_procs" && "$hidden_procs_count" -gt 0 ]]; then
        ((total_findings += hidden_procs_count))
        check_json=$(cat <<EOF
{
    "id": "malware.hidden_processes",
    "check_id": "malware.hidden_processes",
    "module": "malware",
    "title": "$(i18n 'malware.hidden_processes' 2>/dev/null || echo 'Hidden Processes Detected'): $hidden_procs_count",
    "desc": "$(echo "$hidden_procs" | head -3 | tr '\n' '; ' | sed 's/;$//')",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.investigate_hidden' 2>/dev/null || echo 'Investigate hidden processes - may indicate rootkit')",
    "fix_id": "malware.hidden_processes"
}
EOF
)
        state_add_check "$check_json"
    fi

    # 2. Hidden ports
    local hidden_ports=$(_malware_check_hidden_ports)
    local hidden_ports_count=$(echo "$hidden_ports" | grep -c '.' 2>/dev/null || echo 0)

    if [[ -n "$hidden_ports" && "$hidden_ports_count" -gt 0 ]]; then
        ((total_findings += hidden_ports_count))
        check_json=$(cat <<EOF
{
    "id": "malware.hidden_ports",
    "check_id": "malware.hidden_ports",
    "module": "malware",
    "title": "$(i18n 'malware.hidden_ports' 2>/dev/null || echo 'Hidden Ports Detected'): $hidden_ports_count",
    "desc": "Ports: $(echo "$hidden_ports" | tr '\n' ', ' | sed 's/,$//')",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.investigate_ports' 2>/dev/null || echo 'Investigate hidden ports - may indicate rootkit')",
    "fix_id": "malware.hidden_ports"
}
EOF
)
        state_add_check "$check_json"
    fi

    # 3. LD_PRELOAD hijacking
    local ld_preload=$(_malware_check_ld_preload)
    local ld_preload_count=$(echo "$ld_preload" | grep -c '.' 2>/dev/null || echo 0)

    if [[ -n "$ld_preload" && "$ld_preload_count" -gt 0 ]]; then
        ((total_findings += ld_preload_count))
        check_json=$(cat <<EOF
{
    "id": "malware.ld_preload",
    "check_id": "malware.ld_preload",
    "module": "malware",
    "title": "$(i18n 'malware.ld_preload_hijack' 2>/dev/null || echo 'LD_PRELOAD Hijacking Detected')",
    "desc": "$(echo "$ld_preload" | head -3 | tr '\n' '; ' | sed 's/;$//')",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.remove_ld_preload' 2>/dev/null || echo 'Remove LD_PRELOAD entries - may be library injection attack')",
    "fix_id": "malware.ld_preload"
}
EOF
)
        state_add_check "$check_json"
    fi

    # 4. ld.so.preload
    local lib_preload=$(_malware_check_library_preload)
    local lib_preload_count=$(echo "$lib_preload" | grep -c '.' 2>/dev/null || echo 0)

    if [[ -n "$lib_preload" && "$lib_preload_count" -gt 0 ]]; then
        ((total_findings += lib_preload_count))
        check_json=$(cat <<EOF
{
    "id": "malware.ld_so_preload",
    "check_id": "malware.ld_so_preload",
    "module": "malware",
    "title": "$(i18n 'malware.ld_so_preload' 2>/dev/null || echo 'Suspicious /etc/ld.so.preload')",
    "desc": "$(echo "$lib_preload" | head -3 | tr '\n' '; ' | sed 's/;$//')",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.check_ld_so' 2>/dev/null || echo 'Review and clear /etc/ld.so.preload - rarely needed legitimately')",
    "fix_id": "malware.ld_so_preload"
}
EOF
)
        state_add_check "$check_json"
    fi

    # 5. Suspicious kernel modules
    local sus_lkm=$(_malware_check_suspicious_lkm)
    local sus_lkm_count=$(echo "$sus_lkm" | grep -c '.' 2>/dev/null || echo 0)

    if [[ -n "$sus_lkm" && "$sus_lkm_count" -gt 0 ]]; then
        ((total_findings += sus_lkm_count))
        check_json=$(cat <<EOF
{
    "id": "malware.suspicious_lkm",
    "check_id": "malware.suspicious_lkm",
    "module": "malware",
    "title": "$(i18n 'malware.suspicious_lkm' 2>/dev/null || echo 'Suspicious Kernel Modules'): $sus_lkm_count",
    "desc": "$(echo "$sus_lkm" | head -3 | tr '\n' '; ' | sed 's/;$//')",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.investigate_lkm' 2>/dev/null || echo 'Investigate kernel modules - may be kernel rootkit')",
    "fix_id": "malware.suspicious_lkm"
}
EOF
)
        state_add_check "$check_json"
    fi

    # === Crypto Miner Detection ===
    print_item "$(i18n 'malware.checking_miners' 2>/dev/null || echo 'Checking for crypto miners...')"

    # 6. Crypto mining processes
    local crypto_procs=$(_malware_check_crypto_processes)
    local crypto_procs_count=$(echo "$crypto_procs" | grep -c '|' 2>/dev/null || echo 0)

    if [[ -n "$crypto_procs" && "$crypto_procs_count" -gt 0 ]]; then
        ((total_findings += crypto_procs_count))
        local crypto_list=""
        while IFS='|' read -r pid cmd; do
            [[ -z "$pid" ]] && continue
            crypto_list+="PID $pid: $cmd; "
        done <<< "$crypto_procs"

        check_json=$(cat <<EOF
{
    "id": "malware.crypto_miner",
    "check_id": "malware.crypto_miner",
    "module": "malware",
    "title": "$(i18n 'malware.crypto_miner_found' 2>/dev/null || echo 'Crypto Mining Processes Found'): $crypto_procs_count",
    "desc": "${crypto_list%;*}",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.kill_miner' 2>/dev/null || echo 'Kill mining processes and investigate infection source')",
    "fix_id": "malware.crypto_miner"
}
EOF
)
        state_add_check "$check_json"
    fi

    # 7. Mining pool connections
    local pool_conns=$(_malware_check_crypto_connections)
    local pool_conns_count=$(echo "$pool_conns" | grep -c '.' 2>/dev/null || echo 0)

    if [[ -n "$pool_conns" && "$pool_conns_count" -gt 0 ]]; then
        ((total_findings += pool_conns_count))
        check_json=$(cat <<EOF
{
    "id": "malware.mining_pool_connection",
    "check_id": "malware.mining_pool_connection",
    "module": "malware",
    "title": "$(i18n 'malware.pool_connection' 2>/dev/null || echo 'Mining Pool Connections Detected'): $pool_conns_count",
    "desc": "$(echo "$pool_conns" | head -3 | tr '\n' '; ' | sed 's/;$//')",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.block_pool' 2>/dev/null || echo 'Block mining pool connections and remove malware')",
    "fix_id": "malware.mining_pool_connection"
}
EOF
)
        state_add_check "$check_json"
    fi

    # 8. CPU anomaly (potential mining)
    local cpu_anomaly=$(_malware_check_cpu_anomaly)
    local cpu_anomaly_count=$(echo "$cpu_anomaly" | grep -c '|' 2>/dev/null || echo 0)

    if [[ -n "$cpu_anomaly" && "$cpu_anomaly_count" -gt 0 ]]; then
        local cpu_list=""
        while IFS='|' read -r pid cpu cmd; do
            [[ -z "$pid" ]] && continue
            cpu_list+="PID $pid ($cpu): $cmd; "
        done <<< "$cpu_anomaly"

        check_json=$(cat <<EOF
{
    "id": "malware.cpu_anomaly",
    "check_id": "malware.cpu_anomaly",
    "module": "malware",
    "title": "$(i18n 'malware.cpu_anomaly' 2>/dev/null || echo 'High CPU Usage Detected'): $cpu_anomaly_count processes",
    "desc": "${cpu_list%;*}",
    "status": "failed",
    "severity": "medium",
    "suggestion": "$(i18n 'malware.investigate_cpu' 2>/dev/null || echo 'Investigate high CPU processes - may be crypto mining')",
    "fix_id": "malware.cpu_anomaly"
}
EOF
)
        state_add_check "$check_json"
    fi

    # === WebShell Detection ===
    print_item "$(i18n 'malware.checking_webshell' 2>/dev/null || echo 'Checking for webshells...')"

    # 9. WebShell detection
    local webshells=$(_malware_check_webshell)
    local webshell_count=$(echo "$webshells" | grep -c '|' 2>/dev/null || echo 0)

    if [[ -n "$webshells" && "$webshell_count" -gt 0 ]]; then
        ((total_findings += webshell_count))
        local webshell_list=""
        while IFS='|' read -r file reason; do
            [[ -z "$file" ]] && continue
            webshell_list+="$file; "
        done <<< "$webshells"

        check_json=$(cat <<EOF
{
    "id": "malware.webshell",
    "check_id": "malware.webshell",
    "module": "malware",
    "title": "$(i18n 'malware.webshell_found' 2>/dev/null || echo 'Potential WebShells Found'): $webshell_count",
    "desc": "${webshell_list%;*}",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.remove_webshell' 2>/dev/null || echo 'Review and remove webshells, check access logs for intrusion')",
    "fix_id": "malware.webshell"
}
EOF
)
        state_add_check "$check_json"
    fi

    # === Suspicious Process Detection ===
    print_item "$(i18n 'malware.checking_processes' 2>/dev/null || echo 'Checking for suspicious processes...')"

    # 10. Deleted binaries
    local deleted=$(_malware_check_deleted_binaries)
    local deleted_count=$(echo "$deleted" | grep -c '|' 2>/dev/null || echo 0)

    if [[ -n "$deleted" && "$deleted_count" -gt 0 ]]; then
        ((total_findings += deleted_count))
        local deleted_list=""
        while IFS='|' read -r pid exe cmd; do
            [[ -z "$pid" ]] && continue
            deleted_list+="PID $pid: $exe; "
        done <<< "$deleted"

        check_json=$(cat <<EOF
{
    "id": "malware.deleted_binary",
    "check_id": "malware.deleted_binary",
    "module": "malware",
    "title": "$(i18n 'malware.deleted_binary' 2>/dev/null || echo 'Processes with Deleted Binaries'): $deleted_count",
    "desc": "${deleted_list%;*}",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.investigate_deleted' 2>/dev/null || echo 'Investigate deleted binary processes - common malware technique')",
    "fix_id": "malware.deleted_binary"
}
EOF
)
        state_add_check "$check_json"
    fi

    # 11. memfd execution (fileless)
    local memfd=$(_malware_check_memfd_processes)
    local memfd_count=$(echo "$memfd" | grep -c '|' 2>/dev/null || echo 0)

    if [[ -n "$memfd" && "$memfd_count" -gt 0 ]]; then
        ((total_findings += memfd_count))
        local memfd_list=""
        while IFS='|' read -r pid exe cmd; do
            [[ -z "$pid" ]] && continue
            memfd_list+="PID $pid: $cmd; "
        done <<< "$memfd"

        check_json=$(cat <<EOF
{
    "id": "malware.memfd_execution",
    "check_id": "malware.memfd_execution",
    "module": "malware",
    "title": "$(i18n 'malware.memfd_execution' 2>/dev/null || echo 'Fileless Execution Detected (memfd)'): $memfd_count",
    "desc": "${memfd_list%;*}",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.investigate_memfd' 2>/dev/null || echo 'CRITICAL: Memory-only execution detected - likely advanced malware')",
    "fix_id": "malware.memfd_execution"
}
EOF
)
        state_add_check "$check_json"
    fi

    # 12. Suspicious paths
    local sus_paths=$(_malware_check_suspicious_paths)
    local sus_paths_count=$(echo "$sus_paths" | grep -c '|' 2>/dev/null || echo 0)

    if [[ -n "$sus_paths" && "$sus_paths_count" -gt 0 ]]; then
        ((total_findings += sus_paths_count))
        local sus_list=""
        while IFS='|' read -r pid exe cmd; do
            [[ -z "$pid" ]] && continue
            sus_list+="PID $pid: $exe; "
        done <<< "$sus_paths"

        check_json=$(cat <<EOF
{
    "id": "malware.suspicious_path",
    "check_id": "malware.suspicious_path",
    "module": "malware",
    "title": "$(i18n 'malware.suspicious_path' 2>/dev/null || echo 'Processes from Suspicious Paths'): $sus_paths_count",
    "desc": "${sus_list%;*}",
    "status": "failed",
    "severity": "medium",
    "suggestion": "$(i18n 'malware.investigate_path' 2>/dev/null || echo 'Investigate processes running from /tmp, /dev/shm - common malware locations')",
    "fix_id": "malware.suspicious_path"
}
EOF
)
        state_add_check "$check_json"
    fi

    # === Network Anomaly Detection ===
    print_item "$(i18n 'malware.checking_network' 2>/dev/null || echo 'Checking for network anomalies...')"

    # 13. Reverse shells
    local rev_shells=$(_malware_check_reverse_shells)
    local rev_shells_count=$(echo "$rev_shells" | grep -c '.' 2>/dev/null || echo 0)

    if [[ -n "$rev_shells" && "$rev_shells_count" -gt 0 ]]; then
        ((total_findings += rev_shells_count))
        check_json=$(cat <<EOF
{
    "id": "malware.reverse_shell",
    "check_id": "malware.reverse_shell",
    "module": "malware",
    "title": "$(i18n 'malware.reverse_shell' 2>/dev/null || echo 'Potential Reverse Shell Detected'): $rev_shells_count",
    "desc": "$(echo "$rev_shells" | head -3 | tr '\n' '; ' | sed 's/;$//')",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.investigate_revshell' 2>/dev/null || echo 'CRITICAL: Reverse shell detected - system may be compromised')",
    "fix_id": "malware.reverse_shell"
}
EOF
)
        state_add_check "$check_json"
    fi

    # 14. C2 connections
    local c2_conns=$(_malware_check_c2_connections)
    local c2_count=$(echo "$c2_conns" | grep -c '.' 2>/dev/null || echo 0)

    if [[ -n "$c2_conns" && "$c2_count" -gt 0 ]]; then
        ((total_findings += c2_count))
        check_json=$(cat <<EOF
{
    "id": "malware.c2_connection",
    "check_id": "malware.c2_connection",
    "module": "malware",
    "title": "$(i18n 'malware.c2_connection' 2>/dev/null || echo 'Suspicious C2 Connections'): $c2_count",
    "desc": "$(echo "$c2_conns" | head -3 | tr '\n' '; ' | sed 's/;$//')",
    "status": "failed",
    "severity": "high",
    "suggestion": "$(i18n 'malware.investigate_c2' 2>/dev/null || echo 'Investigate suspicious outbound connections - may be C2 traffic')",
    "fix_id": "malware.c2_connection"
}
EOF
)
        state_add_check "$check_json"
    fi

    # 15. Unusual outbound
    local unusual_out=$(_malware_check_unusual_outbound)
    local unusual_out_count=$(echo "$unusual_out" | grep -c '.' 2>/dev/null || echo 0)

    if [[ -n "$unusual_out" && "$unusual_out_count" -gt 0 ]]; then
        check_json=$(cat <<EOF
{
    "id": "malware.unusual_outbound",
    "check_id": "malware.unusual_outbound",
    "module": "malware",
    "title": "$(i18n 'malware.unusual_outbound' 2>/dev/null || echo 'Unusual Outbound Connections'): $unusual_out_count",
    "desc": "$(echo "$unusual_out" | head -3 | tr '\n' '; ' | sed 's/;$//')",
    "status": "failed",
    "severity": "medium",
    "suggestion": "$(i18n 'malware.investigate_outbound' 2>/dev/null || echo 'Review unusual connection patterns - may indicate C2 beaconing')",
    "fix_id": "malware.unusual_outbound"
}
EOF
)
        state_add_check "$check_json"
    fi

    # Summary check
    if [[ "$total_findings" -eq 0 ]]; then
        check_json=$(cat <<EOF
{
    "id": "malware.clean",
    "check_id": "malware.clean",
    "module": "malware",
    "title": "$(i18n 'malware.no_threats' 2>/dev/null || echo 'No Malware Indicators Found')",
    "desc": "$(i18n 'malware.system_clean' 2>/dev/null || echo 'Lightweight scan completed - no obvious threats detected')",
    "status": "passed",
    "severity": "info"
}
EOF
)
        state_add_check "$check_json"
    fi

    return 0
}

# ==============================================================================
# Fix Functions (ALL ALERT ONLY - NO AUTO MODIFICATIONS)
# ==============================================================================

malware_fix() {
    local fix_id="$1"

    # IMPORTANT: This module NEVER automatically removes malware
    # All fixes are alert-only with manual instructions

    case "$fix_id" in
        malware.hidden_processes)
            print_warn "$(i18n 'malware.critical_alert' 2>/dev/null || echo 'CRITICAL SECURITY ALERT')"
            echo ""
            echo "$(i18n 'malware.hidden_procs_warning' 2>/dev/null || echo 'Hidden processes detected - possible rootkit infection'):"
            echo ""
            local hidden=$(_malware_check_hidden_processes)
            while IFS=':' read -r pid cmdline; do
                [[ -z "$pid" ]] && continue
                echo "  PID: $pid"
                echo "  Command: $cmdline"
                echo "  Check: cat /proc/$pid/status"
                echo ""
            done <<< "$hidden"
            echo "$(i18n 'malware.recommended_actions' 2>/dev/null || echo 'Recommended actions'):"
            echo "  1. $(i18n 'malware.action_backup' 2>/dev/null || echo 'Backup critical data immediately')"
            echo "  2. $(i18n 'malware.action_forensics' 2>/dev/null || echo 'Consider forensic analysis before changes')"
            echo "  3. $(i18n 'malware.action_reinstall' 2>/dev/null || echo 'Plan for system reinstallation')"
            return 1
            ;;

        malware.hidden_ports)
            print_warn "$(i18n 'malware.critical_alert' 2>/dev/null || echo 'CRITICAL SECURITY ALERT')"
            echo ""
            echo "$(i18n 'malware.hidden_ports_warning' 2>/dev/null || echo 'Hidden network ports detected'):"
            echo ""
            local ports=$(_malware_check_hidden_ports)
            echo "$ports" | while read -r port; do
                echo "  Port: $port"
            done
            echo ""
            echo "$(i18n 'malware.investigate_ports_cmd' 2>/dev/null || echo 'Investigation commands'):"
            echo "  lsof -i :PORT"
            echo "  fuser -v PORT/tcp"
            return 1
            ;;

        malware.ld_preload|malware.ld_so_preload)
            print_warn "$(i18n 'malware.critical_alert' 2>/dev/null || echo 'CRITICAL SECURITY ALERT')"
            echo ""
            echo "$(i18n 'malware.ld_preload_warning' 2>/dev/null || echo 'Library preloading detected - potential rootkit'):"
            echo ""
            echo "$(i18n 'malware.check_files' 2>/dev/null || echo 'Check these files'):"
            echo "  /etc/ld.so.preload"
            echo "  /etc/profile"
            echo "  /etc/environment"
            echo ""
            echo "$(i18n 'malware.to_clear' 2>/dev/null || echo 'To clear (if confirmed malicious)'):"
            echo "  echo '' > /etc/ld.so.preload"
            echo "  grep -r LD_PRELOAD /etc/profile* /etc/environment"
            return 1
            ;;

        malware.suspicious_lkm)
            print_warn "$(i18n 'malware.critical_alert' 2>/dev/null || echo 'CRITICAL SECURITY ALERT')"
            echo ""
            echo "$(i18n 'malware.lkm_warning' 2>/dev/null || echo 'Suspicious kernel modules detected'):"
            echo ""
            local lkm=$(_malware_check_suspicious_lkm)
            echo "$lkm"
            echo ""
            echo "$(i18n 'malware.lkm_commands' 2>/dev/null || echo 'Investigation commands'):"
            echo "  lsmod"
            echo "  modinfo <module_name>"
            echo "  rmmod <module_name>  # To remove (use caution)"
            return 1
            ;;

        malware.crypto_miner|malware.mining_pool_connection)
            print_warn "$(i18n 'malware.high_alert' 2>/dev/null || echo 'HIGH SECURITY ALERT')"
            echo ""
            echo "$(i18n 'malware.miner_warning' 2>/dev/null || echo 'Crypto mining activity detected'):"
            echo ""
            local procs=$(_malware_check_crypto_processes)
            while IFS='|' read -r pid cmd; do
                [[ -z "$pid" ]] && continue
                echo "  PID: $pid"
                echo "  Command: $cmd"
                echo "  Kill: kill -9 $pid"
                echo ""
            done <<< "$procs"
            echo "$(i18n 'malware.miner_actions' 2>/dev/null || echo 'Remediation steps'):"
            echo "  1. kill -9 <PID>  # Kill mining processes"
            echo "  2. find / -name 'xmrig' -o -name 'minerd' 2>/dev/null  # Find binaries"
            echo "  3. crontab -l  # Check for persistence"
            echo "  4. cat /etc/rc.local  # Check startup scripts"
            return 1
            ;;

        malware.webshell)
            print_warn "$(i18n 'malware.high_alert' 2>/dev/null || echo 'HIGH SECURITY ALERT')"
            echo ""
            echo "$(i18n 'malware.webshell_warning' 2>/dev/null || echo 'Potential webshells detected'):"
            echo ""
            local shells=$(_malware_check_webshell)
            while IFS='|' read -r file reason; do
                [[ -z "$file" ]] && continue
                echo "  File: $file"
                echo "  Reason: $reason"
                echo ""
            done <<< "$shells"
            echo "$(i18n 'malware.webshell_actions' 2>/dev/null || echo 'Remediation steps'):"
            echo "  1. mv <file> <file>.quarantine  # Quarantine suspicious files"
            echo "  2. grep -r 'eval(' /var/www/  # Search for more"
            echo "  3. Check web server access logs for exploitation"
            echo "  4. Review upload functionality and permissions"
            return 1
            ;;

        malware.deleted_binary|malware.memfd_execution)
            print_warn "$(i18n 'malware.critical_alert' 2>/dev/null || echo 'CRITICAL SECURITY ALERT')"
            echo ""
            echo "$(i18n 'malware.fileless_warning' 2>/dev/null || echo 'Fileless/memory-based execution detected'):"
            echo ""
            local procs=$(_malware_check_deleted_binaries)
            local memfd=$(_malware_check_memfd_processes)
            echo "Deleted binaries:"
            while IFS='|' read -r pid exe cmd; do
                [[ -z "$pid" ]] && continue
                echo "  PID: $pid, Exe: $exe"
            done <<< "$procs"
            echo ""
            echo "memfd execution:"
            while IFS='|' read -r pid exe cmd; do
                [[ -z "$pid" ]] && continue
                echo "  PID: $pid, Exe: $exe"
            done <<< "$memfd"
            echo ""
            echo "$(i18n 'malware.fileless_actions' 2>/dev/null || echo 'Investigation'):"
            echo "  cat /proc/<PID>/maps"
            echo "  cat /proc/<PID>/cmdline"
            echo "  ls -la /proc/<PID>/fd/"
            return 1
            ;;

        malware.suspicious_path)
            print_info "$(i18n 'malware.review_alert' 2>/dev/null || echo 'Review Required')"
            echo ""
            echo "$(i18n 'malware.sus_path_warning' 2>/dev/null || echo 'Processes running from suspicious paths'):"
            echo ""
            local procs=$(_malware_check_suspicious_paths)
            while IFS='|' read -r pid exe cmd; do
                [[ -z "$pid" ]] && continue
                echo "  PID: $pid"
                echo "  Path: $exe"
                echo "  Command: $cmd"
                echo ""
            done <<< "$procs"
            return 1
            ;;

        malware.reverse_shell|malware.c2_connection)
            print_warn "$(i18n 'malware.critical_alert' 2>/dev/null || echo 'CRITICAL SECURITY ALERT')"
            echo ""
            echo "$(i18n 'malware.c2_warning' 2>/dev/null || echo 'Suspicious network activity detected'):"
            echo ""
            echo "$(i18n 'malware.c2_actions' 2>/dev/null || echo 'Immediate actions'):"
            echo "  1. ss -tnp  # List all connections with processes"
            echo "  2. Block suspicious IPs with firewall"
            echo "  3. Kill suspicious processes"
            echo "  4. Check for persistence mechanisms"
            echo ""
            echo "$(i18n 'malware.network_block' 2>/dev/null || echo 'To block an IP'):"
            echo "  ufw deny out to <IP>"
            echo "  iptables -A OUTPUT -d <IP> -j DROP"
            return 1
            ;;

        malware.unusual_outbound)
            print_info "$(i18n 'malware.review_alert' 2>/dev/null || echo 'Review Required')"
            echo ""
            echo "$(i18n 'malware.outbound_warning' 2>/dev/null || echo 'Unusual outbound connection patterns'):"
            echo ""
            local conns=$(_malware_check_unusual_outbound)
            echo "$conns"
            echo ""
            echo "$(i18n 'malware.investigate_cmd' 2>/dev/null || echo 'Investigation commands'):"
            echo "  ss -tnp | grep <IP>"
            echo "  whois <IP>"
            echo "  nslookup <IP>"
            return 1
            ;;

        malware.cpu_anomaly)
            print_info "$(i18n 'malware.review_alert' 2>/dev/null || echo 'Review Required')"
            echo ""
            echo "$(i18n 'malware.cpu_warning' 2>/dev/null || echo 'High CPU usage detected'):"
            echo ""
            local procs=$(_malware_check_cpu_anomaly)
            while IFS='|' read -r pid cpu cmd; do
                [[ -z "$pid" ]] && continue
                echo "  PID: $pid, CPU: $cpu"
                echo "  Command: $cmd"
            done <<< "$procs"
            echo ""
            echo "$(i18n 'malware.cpu_cmd' 2>/dev/null || echo 'Monitor with'):"
            echo "  top -p <PID>"
            echo "  strace -p <PID>"
            return 1
            ;;

        *)
            log_warn "Unknown fix_id: $fix_id"
            return 1
            ;;
    esac
}
